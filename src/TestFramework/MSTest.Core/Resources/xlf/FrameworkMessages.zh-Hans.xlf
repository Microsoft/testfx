<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" source-language="en" target-language="zh-Hans" original="../FrameworkMessages.resx">
    <body>
      <trans-unit id="ElementNumbersDontMatch">
        <source>集合中元素的数量不匹配。应为: &lt;{1}&gt;，实际为: &lt;{2}&gt;。{0}</source>
        <target state="new">集合中元素的数量不匹配。应为: &lt;{1}&gt;，实际为: &lt;{2}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="IsMatchFail">
        <source>字符串“{0}”与模式“{1}”不匹配。{2}。</source>
        <target state="new">字符串“{0}”与模式“{1}”不匹配。{2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="IsInstanceOfFailMsg">
        <source>{0} 类型应为: &lt;{1}&gt;。类型实为: &lt;{2}&gt;。</source>
        <target state="new">{0} 类型应为: &lt;{1}&gt;。类型实为: &lt;{2}&gt;。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="ContainsFail">
        <source>字符串“{0}”不包含字符串“{1}”。{2}。</source>
        <target state="new">字符串“{0}”不包含字符串“{1}”。{2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="InternalObjectNotValid">
        <source>所引用的内部对象不再有效。</source>
        <target state="new">所引用的内部对象不再有效。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="StartsWithFail">
        <source>字符串“{0}”没有以字符串“{1}”开头。{2}。</source>
        <target state="new">字符串“{0}”没有以字符串“{1}”开头。{2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreEqualDifferentTypesFailMsg">
        <source>应为: &lt;{1} ({2})&gt;，实际为: &lt;{3} ({4})&gt;。{0}</source>
        <target state="new">应为: &lt;{1} ({2})&gt;，实际为: &lt;{3} ({4})&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="BothSameElements">
        <source>这两个集合包含相同的元素。{0}</source>
        <target state="new">这两个集合包含相同的元素。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="InvalidParameterToAssert">
        <source>参数“{0}”无效。{1}。</source>
        <target state="new">参数“{0}”无效。{1}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreNotEqualDeltaFailMsg">
        <source>预期值 &lt;{1}&gt; 和实际值 &lt;{2}&gt; 之间的差应大于 &lt;{3}&gt;。{0}</source>
        <target state="new">预期值 &lt;{1}&gt; 和实际值 &lt;{2}&gt; 之间的差应大于 &lt;{3}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="ElementsAtIndexDontMatch">
        <source>索引 {0} 处的元素不匹配。</source>
        <target state="new">索引 {0} 处的元素不匹配。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="BothCollectionsSameReference">
        <source>这两个集合引用指向同一个集合对象。{0}</source>
        <target state="new">这两个集合引用指向同一个集合对象。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AsyncUITestMethodNotSupported">
        <source>不支持具有 UITestMethodAttribute 的异步 TestMethod。请删除异步或使用 TestMethodAttribute。</source>
        <target state="new">不支持具有 UITestMethodAttribute 的异步 TestMethod。请删除异步或使用 TestMethodAttribute。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="PrivateAccessorConstructorNotFound">
        <source>
      未能找到具有指定签名的构造函数。可能需要重新生成专用访问器，
      或者该成员可能是私有成员并且是在基类上定义的。如果属于后一种情况，则需要将定义
      该成员的类型传递到 PrivateObject 的构造函数。
    </source>
        <target state="new">
      未能找到具有指定签名的构造函数。可能需要重新生成专用访问器，
      或者该成员可能是私有成员并且是在基类上定义的。如果属于后一种情况，则需要将定义
      该成员的类型传递到 PrivateObject 的构造函数。
    </target>
        <note></note>
      </trans-unit>
      <trans-unit id="AssertionFailed">
        <source>{0} 失败。{1}</source>
        <target state="new">{0} 失败。{1}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="DoNotUseAssertEquals">
        <source>Assert.Equals 不应用于断言。请改用 Assert.AreEqual 和重载。</source>
        <target state="new">Assert.Equals 不应用于断言。请改用 Assert.AreEqual 和重载。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_TestMethodNoExceptionDefault">
        <source>测试方法未引发异常。预期会因测试方法上定义的属性 {0} 引发一个异常。</source>
        <target state="new">测试方法未引发异常。预期会因测试方法上定义的属性 {0} 引发一个异常。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="Common_NullInMessages">
        <source>(NULL)</source>
        <target state="new">(NULL)</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_TestMethodWrongExceptionDerivedAllowed">
        <source>测试方法引发异常 {0}，但预期异常是 {1} 或其派生类型。异常消息: {2}</source>
        <target state="new">测试方法引发异常 {0}，但预期异常是 {1} 或其派生类型。异常消息: {2}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="ElementTypesAtIndexDontMatch2">
        <source>索引 {1} 处的元素为(NULL)。类型应为: &lt;{2}&gt;。{0}</source>
        <target state="new">索引 {1} 处的元素为(NULL)。类型应为: &lt;{2}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="NoExceptionThrown">
        <source>未引发异常。原来预计会引发异常 {1}。{0}</source>
        <target state="new">未引发异常。原来预计会引发异常 {1}。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="DataDrivenResultDisplayName">
        <source>{0} ({1})</source>
        <target state="new">{0} ({1})</target>
        <note></note>
      </trans-unit>
      <trans-unit id="NoDataRow">
        <source>未指定 DataRowAttribute。 DataTestMethodAttribute 至少需要一个 DataRowAttribute。</source>
        <target state="new">未指定 DataRowAttribute。 DataTestMethodAttribute 至少需要一个 DataRowAttribute。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="CollectionEqualReason">
        <source>{0}({1})</source>
        <target state="new">{0}({1})</target>
        <note></note>
      </trans-unit>
      <trans-unit id="EqualsTesterInvalidArgs">
        <source>参数无效 - EqualsTester 不能使用 NULL。</source>
        <target state="new">参数无效 - EqualsTester 不能使用 NULL。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AccessStringInvalidSyntax">
        <source>访问字符串的语法无效。</source>
        <target state="new">访问字符串的语法无效。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="ElementTypesAtIndexDontMatch">
        <source>索引 {1} 处的元素不是预期类型。类型应为: &lt;{2}&gt;，类型实为: &lt;{3}&gt;。{0}</source>
        <target state="new">索引 {1} 处的元素不是预期类型。类型应为: &lt;{2}&gt;，类型实为: &lt;{3}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="ErrorInvalidCast">
        <source>无法将类型为 {0} 的对象转换为 {1}。</source>
        <target state="new">无法将类型为 {0} 的对象转换为 {1}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreNotEqualFailMsg">
        <source>应为 &lt;{1}&gt; 以外的任意值，实际为: &lt;{2}&gt;。{0}</source>
        <target state="new">应为 &lt;{1}&gt; 以外的任意值，实际为: &lt;{2}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_TestMethodNoException">
        <source>测试方法未引发预期异常 {0}. {1}</source>
        <target state="new">测试方法未引发预期异常 {0}. {1}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="IsNotMatchFail">
        <source>字符串“{0}”与模式“{1}”匹配。{2}。</source>
        <target state="new">字符串“{0}”与模式“{1}”匹配。{2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_TestMethodWrongException">
        <source>测试方法引发异常 {0}，但预期异常是 {1}。异常消息: {2}</source>
        <target state="new">测试方法引发异常 {0}，但预期异常是 {1}。异常消息: {2}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="WrongExceptionThrown">
        <source>原来预计会引发异常 {1}，但引发了异常 {2}。{0}
异常消息: {3}
堆栈跟踪: {4}</source>
        <target state="new">原来预计会引发异常 {1}，但引发了异常 {2}。{0}
异常消息: {3}
堆栈跟踪: {4}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="IsNotInstanceOfFailMsg">
        <source>错误类型: &lt;{1}&gt;，实际类型: &lt;{2}&gt;。{0}</source>
        <target state="new">错误类型: &lt;{1}&gt;，实际类型: &lt;{2}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreEqualDeltaFailMsg">
        <source>预期值 &lt;{1}&gt; 和实际值 &lt;{2}&gt; 之间的差不应大于 &lt;{3}&gt;。{0}</source>
        <target state="new">预期值 &lt;{1}&gt; 和实际值 &lt;{2}&gt; 之间的差不应大于 &lt;{3}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_FailedToGetExceptionMessage">
        <source>(因异常而未能获取类型为 {0} 的异常的消息。)</source>
        <target state="new">(因异常而未能获取类型为 {0} 的异常的消息。)</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AllItemsAreUniqueFailMsg">
        <source>找到了重复项: &lt;{1}&gt;。{0}</source>
        <target state="new">找到了重复项: &lt;{1}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="Common_ObjectString">
        <source>(对象)</source>
        <target state="new">(对象)</target>
        <note></note>
      </trans-unit>
      <trans-unit id="EndsWithFail">
        <source>字符串“{0}”不以字符串“{1}”结尾。{2}。</source>
        <target state="new">字符串“{0}”不以字符串“{1}”结尾。{2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="NumberOfElementsDiff">
        <source>不同数量的元素。</source>
        <target state="new">不同数量的元素。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="NullParameterToAssert">
        <source>参数“{0}”无效。值不能为 NULL。{1}。</source>
        <target state="new">参数“{0}”无效。值不能为 NULL。{1}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="BothCollectionsSameElements">
        <source>这两个集合包含相同的元素。</source>
        <target state="new">这两个集合包含相同的元素。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="BothCollectionsEmpty">
        <source>这两个集合都为空。{0}</source>
        <target state="new">这两个集合都为空。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreEqualCaseFailMsg">
        <source>应为: &lt;{1}&gt;。实际值的大小写有所不同: &lt;{2}&gt;。{0}</source>
        <target state="new">应为: &lt;{1}&gt;。实际值的大小写有所不同: &lt;{2}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="InvalidPropertyType">
        <source>属性 {0} 的类型为 {1}；类型应为 {2}。</source>
        <target state="new">属性 {0} 的类型为 {1}；类型应为 {2}。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreSameGivenValues">
        <source>不要向 AreSame() 传递值类型。转换为 Object 的值将永远不会相等。请考虑使用 AreEqual()。{0}</source>
        <target state="new">不要向 AreSame() 传递值类型。转换为 Object 的值将永远不会相等。请考虑使用 AreEqual()。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="UTF_ExpectedExceptionTypeMustDeriveFromException">
        <source>预期的异常类型必须为 System.Exception 或从 System.Exception 派生的类型。</source>
        <target state="new">预期的异常类型必须为 System.Exception 或从 System.Exception 派生的类型。</target>
        <note></note>
      </trans-unit>
      <trans-unit id="AreEqualFailMsg">
        <source>应为: &lt;{1}&gt;，实际为: &lt;{2}&gt;。{0}</source>
        <target state="new">应为: &lt;{1}&gt;，实际为: &lt;{2}&gt;。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="ActualHasMismatchedElements">
        <source>所需集合包含 &lt;{2}&gt; 的 {1} 个匹配项。实际集合包含 {3} 个匹配项。{0}</source>
        <target state="new">所需集合包含 &lt;{2}&gt; 的 {1} 个匹配项。实际集合包含 {3} 个匹配项。{0}</target>
        <note></note>
      </trans-unit>
      <trans-unit id="PrivateAccessorMemberNotFound">
        <source>
      未能找到指定的成员({0})。可能需要重新生成专用访问器，
      或者该成员可能是私有成员并且是在基类上定义的。如果属于后一种情况，则需要将定义
      该成员的类型传递到 PrivateObject 的构造函数中。
    </source>
        <target state="new">
      未能找到指定的成员({0})。可能需要重新生成专用访问器，
      或者该成员可能是私有成员并且是在基类上定义的。如果属于后一种情况，则需要将定义
      该成员的类型传递到 PrivateObject 的构造函数中。
    </target>
        <note></note>
      </trans-unit>
    </body>
  </file>
</xliff>